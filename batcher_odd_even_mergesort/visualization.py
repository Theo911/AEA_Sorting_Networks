"""
Visualization for Batcher's Odd-Even Mergesort sorting networks.

This module provides functions to generate visual representations
of sorting networks generated by the Batcher's Odd-Even Mergesort algorithm.
All functions are used by the Flask web application to create 
interactive visualizations.
"""

import matplotlib.pyplot as plt
from typing import List, Tuple

from network_properties import find_parallel_layers


def draw_network(comparators: List[Tuple[int, int]], n_wires: int, title: str = "Batcher's Odd-Even Mergesort Network"):
    """
    Draw a sorting network with wires and comparators.
    
    Args:
        comparators: List of (i,j) comparator pairs
        n_wires: Number of wires in the network
        title: Title for the plot
        
    Returns:
        Matplotlib figure with the network visualization
    """
    fig = plt.figure(figsize=(12, n_wires * 0.6))
    plt.title(title)
    plt.axis('off')
    
    # Draw horizontal wires
    for i in range(n_wires):
        plt.plot([0, len(comparators) + 1], [i, i], 'k-', linewidth=1.5)
    
    # Draw comparators as vertical lines with connection dots
    for idx, (i, j) in enumerate(comparators):
        x_pos = idx + 1
        
        # Draw vertical line connecting the two wires
        plt.plot([x_pos, x_pos], [i, j], 'r-', linewidth=2)
        
        # Draw dots at connection points
        plt.plot(x_pos, i, 'ko', markersize=6)
        plt.plot(x_pos, j, 'ko', markersize=6)
    
    # Label
    plt.text(-0.5, n_wires / 2, "Input", rotation=90, ha='center', va='center')
    plt.text(len(comparators) + 1.5, n_wires / 2, "Output", rotation=90, ha='center', va='center')
    
    plt.tight_layout()
    return fig


def visualize_network_execution(comparators: List[Tuple[int, int]], input_values: List[int]):
    """
    Visualize the execution of a sorting network on a specific input.
    
    Args:
        comparators: List of (i,j) comparator pairs
        input_values: List of input values to be sorted
        
    Returns:
        Matplotlib figure with the execution visualization
    """
    n_wires = len(input_values)
    
    fig = plt.figure(figsize=(12, n_wires * 0.8))
    plt.title(f"Execution of Batcher's Network on {input_values}")
    plt.axis('off')
    
    # Current state of the values
    current_state = input_values.copy()
    
    # Draw horizontal wires
    for i in range(n_wires):
        plt.plot([0, len(comparators) + 1], [i, i], 'k-', linewidth=1.5)
        
        # Add input value - positioned above the wire for better visibility
        plt.text(-0.5, i + 0.2, str(input_values[i]), ha='center', va='center',
                 bbox=dict(facecolor='white', alpha=0.7))
    
    # Draw comparators and update values
    for idx, (i, j) in enumerate(comparators):
        x_pos = idx + 1
        
        # Determine if swap is needed
        color = 'b' if current_state[i] <= current_state[j] else 'r'
        
        # Draw vertical line
        plt.plot([x_pos, x_pos], [i, j], color=color, linewidth=2)
        
        # Draw connection points
        plt.plot(x_pos, i, 'ko', markersize=6)
        plt.plot(x_pos, j, 'ko', markersize=6)
        
        # Add values before comparison - positioned above the wire
        plt.text(x_pos - 0.3, i + 0.2, str(current_state[i]), ha='center', va='center', fontsize=8)
        plt.text(x_pos - 0.3, j + 0.2, str(current_state[j]), ha='center', va='center', fontsize=8)
        
        # Apply comparison
        if current_state[i] > current_state[j]:
            current_state[i], current_state[j] = current_state[j], current_state[i]
        
        # Add values after comparison - positioned above the wire
        plt.text(x_pos + 0.3, i + 0.2, str(current_state[i]), ha='center', va='center', fontsize=8)
        plt.text(x_pos + 0.3, j + 0.2, str(current_state[j]), ha='center', va='center', fontsize=8)
    
    # Add output values - positioned above the wire
    for i in range(n_wires):
        plt.text(len(comparators) + 1.5, i + 0.2, str(current_state[i]), ha='center', va='center',
                 bbox=dict(facecolor='white', alpha=0.7))
    
    plt.tight_layout()
    return fig


def draw_depth_layers(comparators: List[Tuple[int, int]], n_wires: int):
    """
    Visualize a sorting network with layers colored by depth (parallel execution).
    
    Args:
        comparators: List of (i,j) comparator pairs
        n_wires: Number of wires in the network
        
    Returns:
        A tuple of (matplotlib figure with depth visualization, layers data)
    """
    # Use the canonical implementation from network_properties
    layers = find_parallel_layers(comparators, n_wires)
    
    # Create visualization
    fig = plt.figure(figsize=(12, n_wires * 0.6))
    plt.title(f"Batcher's Network by Depth (Parallel Execution)\nDepth: {len(layers)} layers")
    plt.axis('off')
    
    # Draw horizontal wires
    for i in range(n_wires):
        plt.plot([0, len(layers) + 1], [i, i], 'k-', linewidth=1.5)
    
    # Draw comparators by layer
    colors = plt.cm.tab10.colors
    for layer_idx, layer in enumerate(layers):
        x_pos = layer_idx + 1
        color = colors[layer_idx % len(colors)]
        
        for i, j in layer:
            # Draw vertical line
            plt.plot([x_pos, x_pos], [i, j], color=color, linewidth=2)
            
            # Draw connection points
            plt.plot(x_pos, i, 'ko', markersize=6)
            plt.plot(x_pos, j, 'ko', markersize=6)
    
    # Label layers
    for layer_idx in range(len(layers)):
        plt.text(layer_idx + 1, -0.5, f"L{layer_idx}", ha='center', va='center')
    
    plt.tight_layout()
    return fig, layers 