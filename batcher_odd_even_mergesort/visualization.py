"""
Visualization for Batcher's Odd-Even Mergesort sorting networks.

This module provides functions to generate clear visual representations
of sorting networks generated by the Batcher's Odd-Even Mergesort algorithm.
"""

import matplotlib.pyplot as plt
import numpy as np
from typing import List, Tuple
import matplotlib.animation as animation
import os

# Create results directory if it doesn't exist
RESULTS_DIR = "results"
os.makedirs(RESULTS_DIR, exist_ok=True)


def draw_network(comparators: List[Tuple[int, int]], n_wires: int, title: str = "Batcher's Odd-Even Mergesort Network"):
    """
    Draw a sorting network with wires and comparators.
    
    Args:
        comparators: List of (i,j) comparator pairs
        n_wires: Number of wires in the network
        title: Title for the plot
    """
    plt.figure(figsize=(12, n_wires * 0.6))
    plt.title(title)
    plt.axis('off')
    
    # Draw horizontal wires
    for i in range(n_wires):
        plt.plot([0, len(comparators) + 1], [i, i], 'k-', linewidth=1.5)
    
    # Draw comparators as vertical lines with connection dots
    for idx, (i, j) in enumerate(comparators):
        x_pos = idx + 1
        
        # Draw vertical line connecting the two wires
        plt.plot([x_pos, x_pos], [i, j], 'r-', linewidth=2)
        
        # Draw dots at connection points
        plt.plot(x_pos, i, 'ko', markersize=6)
        plt.plot(x_pos, j, 'ko', markersize=6)
    
    # Label
    plt.text(-0.5, n_wires / 2, "Input", rotation=90, ha='center', va='center')
    plt.text(len(comparators) + 1.5, n_wires / 2, "Output", rotation=90, ha='center', va='center')
    
    plt.tight_layout()
    return plt


def visualize_network_execution(comparators: List[Tuple[int, int]], input_values: List[int]):
    """
    Visualize the execution of a sorting network on a specific input.
    
    Args:
        comparators: List of (i,j) comparator pairs
        input_values: List of input values to be sorted
    """
    n_wires = len(input_values)
    
    plt.figure(figsize=(12, n_wires * 0.8))
    plt.title(f"Execution of Batcher's Network on {input_values}")
    plt.axis('off')
    
    # Current state of the values
    current_state = input_values.copy()
    
    # Draw horizontal wires
    for i in range(n_wires):
        plt.plot([0, len(comparators) + 1], [i, i], 'k-', linewidth=1.5)
        
        # Add input value
        plt.text(-0.5, i, str(input_values[i]), ha='center', va='center',
                 bbox=dict(facecolor='white', alpha=0.7))
    
    # Draw comparators and update values
    for idx, (i, j) in enumerate(comparators):
        x_pos = idx + 1
        
        # Determine if swap is needed
        color = 'b' if current_state[i] <= current_state[j] else 'r'
        
        # Draw vertical line
        plt.plot([x_pos, x_pos], [i, j], color=color, linewidth=2)
        
        # Draw connection points
        plt.plot(x_pos, i, 'ko', markersize=6)
        plt.plot(x_pos, j, 'ko', markersize=6)
        
        # Add values before comparison
        plt.text(x_pos - 0.3, i, str(current_state[i]), ha='center', va='center', fontsize=8)
        plt.text(x_pos - 0.3, j, str(current_state[j]), ha='center', va='center', fontsize=8)
        
        # Apply comparison
        if current_state[i] > current_state[j]:
            current_state[i], current_state[j] = current_state[j], current_state[i]
        
        # Add values after comparison
        plt.text(x_pos + 0.3, i, str(current_state[i]), ha='center', va='center', fontsize=8)
        plt.text(x_pos + 0.3, j, str(current_state[j]), ha='center', va='center', fontsize=8)
    
    # Add output values
    for i in range(n_wires):
        plt.text(len(comparators) + 1.5, i, str(current_state[i]), ha='center', va='center',
                 bbox=dict(facecolor='white', alpha=0.7))
    
    plt.tight_layout()
    return plt


def draw_depth_layers(comparators: List[Tuple[int, int]], n_wires: int):
    """
    Visualize a sorting network with layers colored by depth (parallel execution).
    
    Args:
        comparators: List of (i,j) comparator pairs
        n_wires: Number of wires in the network
    """
    # Calculate layers
    layers = []
    wire_usage = [-1] * n_wires
    
    for i, j in comparators:
        # Find earliest layer where this comparator can be placed
        earliest_layer = max(wire_usage[i], wire_usage[j]) + 1
        
        # Add layers if needed
        while len(layers) <= earliest_layer:
            layers.append([])
        
        # Add comparator to layer
        layers[earliest_layer].append((i, j))
        wire_usage[i] = earliest_layer
        wire_usage[j] = earliest_layer
    
    # Create visualization
    plt.figure(figsize=(12, n_wires * 0.6))
    plt.title(f"Batcher's Network by Depth (Parallel Execution)\nDepth: {len(layers)} layers")
    plt.axis('off')
    
    # Draw horizontal wires
    for i in range(n_wires):
        plt.plot([0, len(layers) + 1], [i, i], 'k-', linewidth=1.5)
    
    # Draw comparators by layer
    colors = plt.cm.tab10.colors
    for layer_idx, layer in enumerate(layers):
        x_pos = layer_idx + 1
        color = colors[layer_idx % len(colors)]
        
        for i, j in layer:
            # Draw vertical line
            plt.plot([x_pos, x_pos], [i, j], color=color, linewidth=2)
            
            # Draw connection points
            plt.plot(x_pos, i, 'ko', markersize=6)
            plt.plot(x_pos, j, 'ko', markersize=6)
    
    # Label layers
    for layer_idx in range(len(layers)):
        plt.text(layer_idx + 1, -0.5, f"L{layer_idx}", ha='center', va='center')
    
    plt.tight_layout()
    return plt, layers


def create_animation(comparators: List[Tuple[int, int]], input_values: List[int]):
    """
    Create an animation showing step-by-step execution of the sorting network.
    
    Args:
        comparators: List of (i,j) comparator pairs
        input_values: List of input values to be sorted
        
    Returns:
        Animation object
    """
    n_wires = len(input_values)
    
    # Setup the figure
    fig, ax = plt.subplots(figsize=(10, n_wires * 0.7))
    ax.set_xlim(-1, len(comparators) + 2)
    ax.set_ylim(-1, n_wires)
    ax.axis('off')
    
    # Draw horizontal wires
    for i in range(n_wires):
        ax.plot([0, len(comparators) + 1], [i, i], 'k-', linewidth=1.5)
    
    # Text for values
    value_texts = []
    current_state = input_values.copy()
    
    # Initial state
    for i in range(n_wires):
        txt = ax.text(0, i, str(current_state[i]), ha='center', va='center', fontsize=10,
                     bbox=dict(facecolor='white', alpha=0.7))
        value_texts.append(txt)
    
    def update(frame):
        if frame == 0:
            # Initial state
            for i in range(n_wires):
                value_texts[i].set_position((0, i))
                value_texts[i].set_text(str(input_values[i]))
            
            # Clear any comparator lines
            for artist in ax.lines[n_wires:]:
                artist.remove()
            
            ax.set_title("Initial state")
            return value_texts
            
        # Process comparator step
        if frame <= len(comparators):
            i, j = comparators[frame-1]
            current_values = [int(text.get_text()) for text in value_texts]
            
            # Draw comparator
            x_pos = frame
            line1 = ax.plot([x_pos, x_pos], [i, j], 'r-', linewidth=2)[0]
            dot1 = ax.plot(x_pos, i, 'ko', markersize=6)[0]
            dot2 = ax.plot(x_pos, j, 'ko', markersize=6)[0]
            
            # Apply comparator
            if current_values[i] > current_values[j]:
                current_values[i], current_values[j] = current_values[j], current_values[i]
            
            # Update texts
            for idx in range(n_wires):
                value_texts[idx].set_position((x_pos + 0.2, idx))
                value_texts[idx].set_text(str(current_values[idx]))
            
            ax.set_title(f"After comparator {frame}: ({i},{j})")
        else:
            # Final state
            ax.set_title("Final sorted result")
            
        return value_texts
    
    anim = animation.FuncAnimation(fig, update, frames=len(comparators)+2, 
                                  interval=1000, blit=True)
    
    return anim


if __name__ == "__main__":
    from batcher_odd_even_mergesort import generate_sorting_network
    
    # Example usage with n=8
    n = 8
    comparators = generate_sorting_network(n)
    
    # Draw the network
    plt1 = draw_network(comparators, n)
    plt1.savefig(os.path.join(RESULTS_DIR, "batcher_network.png"))
    
    # Draw depth layers
    plt2, layers = draw_depth_layers(comparators, n)
    plt2.savefig(os.path.join(RESULTS_DIR, "batcher_depth_layers.png"))
    print(f"Network depth: {len(layers)} parallel steps")
    
    # Visualize execution on sample data
    input_values = [5, 2, 7, 1, 8, 4, 6, 3]
    plt3 = visualize_network_execution(comparators, input_values)
    plt3.savefig(os.path.join(RESULTS_DIR, "batcher_execution.png"))
    
    # Show animations
    anim = create_animation(comparators, input_values)
    anim.save(os.path.join(RESULTS_DIR, 'batcher_animation.gif'), writer='pillow', fps=1)
    
    plt.show() 