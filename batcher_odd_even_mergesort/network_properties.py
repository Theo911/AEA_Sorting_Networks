"""
Network Properties Analysis for Batcher's Odd-Even Mergesort.

This module analyzes the mathematical properties of sorting networks
generated by Batcher's Odd-Even Mergesort algorithm, including:
- Zero-one principle verification
- Parallel execution layers analysis
- Network structure properties
"""

import itertools
import numpy as np
from typing import List, Tuple, Dict
import os

from batcher_odd_even_mergesort import generate_sorting_network, apply_comparators


def verify_zero_one_principle(n: int, comparators: List[Tuple[int, int]]) -> bool:
    """
    Verify that the network sorts all 2^n binary inputs correctly.
    
    Args:
        n: Number of inputs
        comparators: List of (i,j) comparator pairs
        
    Returns:
        True if the network sorts all binary inputs correctly
    """
    # For n=0 or n=1, sorting is trivial
    if n <= 1:
        return True
        
    # Special cases for n=2 and n=3 
    if n == 2 and len(comparators) < 1:
        return False
    if n == 3 and len(comparators) < 3:
        # For n=3, we need at least 3 comparators for a complete sorting network
        return False
        
    try:
        # Generate all 2^n binary inputs
        for input_bits in itertools.product([0, 1], repeat=n):
            output = apply_comparators(list(input_bits), comparators)
            
            # Check if sorted
            if not all(output[i] <= output[i+1] for i in range(len(output)-1)):
                return False
        
        return True
    except Exception as e:
        # Log the error but don't crash - this is just a verification
        print(f"Error in zero-one principle verification: {e}")
        return False


def find_parallel_layers(comparators: List[Tuple[int, int]], n_wires: int) -> List[List[Tuple[int, int]]]:
    """
    Identify comparators that can be executed in parallel.
    
    Args:
        comparators: List of (i,j) comparator pairs
        n_wires: Number of wires
        
    Returns:
        List of lists containing comparators that can be executed in parallel
    """
    layers = []
    wire_usage = [-1] * n_wires  # Last layer where each wire was used
    
    for i, j in comparators:
        # Find the earliest layer where this comparator can be placed
        earliest_layer = max(wire_usage[i], wire_usage[j]) + 1
        
        # Add layers if needed
        while len(layers) <= earliest_layer:
            layers.append([])
        
        # Add comparator to layer
        layers[earliest_layer].append((i, j))
        wire_usage[i] = earliest_layer
        wire_usage[j] = earliest_layer
    
    return layers


def analyze_layer_properties(comparators: List[Tuple[int, int]], n_wires: int) -> Dict:
    """
    Analyze properties of parallel execution layers.
    
    Args:
        comparators: List of (i,j) comparator pairs
        n_wires: Number of wires
        
    Returns:
        Dictionary with layer properties
    """
    layers = find_parallel_layers(comparators, n_wires)
    
    # Analyze each layer
    layer_sizes = [len(layer) for layer in layers]
    
    return {
        "total_layers": len(layers),
        "layers": layers,
        "layer_sizes": layer_sizes,
        "max_comparators_per_layer": max(layer_sizes) if layer_sizes else 0,
        "min_comparators_per_layer": min(layer_sizes) if layer_sizes else 0,
        "avg_comparators_per_layer": sum(layer_sizes) / len(layers) if layers else 0
    }


def analyze_wire_usage(comparators: List[Tuple[int, int]], n_wires: int) -> Dict:
    """
    Analyze how many times each wire is used in comparators.
    
    Args:
        comparators: List of (i,j) comparator pairs
        n_wires: Number of wires
        
    Returns:
        Dictionary with wire usage statistics
    """
    wire_usage = [0] * n_wires
    
    for i, j in comparators:
        wire_usage[i] += 1
        wire_usage[j] += 1
    
    return {
        "wire_usage": wire_usage,
        "max_usage": max(wire_usage),
        "min_usage": min(wire_usage),
        "avg_usage": sum(wire_usage) / n_wires
    }


def analyze_comparator_distribution(comparators: List[Tuple[int, int]], n_wires: int) -> Dict:
    """
    Analyze the distribution of comparators across wire pairs.
    
    Args:
        comparators: List of (i,j) comparator pairs
        n_wires: Number of wires
        
    Returns:
        Dictionary with comparator distribution information
    """
    # Count occurrences of each wire pair
    pair_counts = {}
    for i, j in comparators:
        if (i, j) in pair_counts:
            pair_counts[(i, j)] += 1
        else:
            pair_counts[(i, j)] = 1
    
    # Analyze distribution
    counts = list(pair_counts.values())
    
    return {
        "pair_counts": pair_counts,
        "unique_pairs": len(pair_counts),
        "max_count": max(counts) if counts else 0,
        "min_count": min(counts) if counts else 0,
        "avg_count": sum(counts) / len(counts) if counts else 0
    }


def compute_comparisons_per_input(comparators: List[Tuple[int, int]], n_wires: int, trials: int = 100) -> Dict:
    """
    Compute the average number of comparisons actually performed for random inputs.
    
    Args:
        comparators: List of (i,j) comparator pairs
        n_wires: Number of wires
        trials: Number of random trials
        
    Returns:
        Dictionary with comparison statistics
    """
    comparison_counts = []
    
    for _ in range(trials):
        # Generate random input
        input_values = np.random.randint(0, 100, n_wires).tolist()
        
        # Track comparisons
        count = 0
        current = input_values.copy()
        
        for i, j in comparators:
            # If comparison leads to swap, count it as active
            if current[i] > current[j]:
                current[i], current[j] = current[j], current[i]
                count += 1
        
        comparison_counts.append(count)
    
    return {
        "active_comparisons": comparison_counts,
        "max_comparisons": max(comparison_counts),
        "min_comparisons": min(comparison_counts),
        "avg_comparisons": sum(comparison_counts) / len(comparison_counts)
    }


def calculate_redundancy(comparators: List[Tuple[int, int]], n_wires: int, trials: int = 100) -> float:
    """
    Calculate the redundancy percentage of the network.
    Redundancy is the percentage of comparisons that don't lead to swaps.
    
    Args:
        comparators: List of (i,j) comparator pairs
        n_wires: Number of wires
        trials: Number of random trials
        
    Returns:
        Redundancy percentage (0-100)
    """
    comparison_data = compute_comparisons_per_input(comparators, n_wires, trials)
    avg_active = comparison_data["avg_comparisons"]
    total_comparators = len(comparators)
    
    # Calculate redundancy percentage
    redundancy = ((total_comparators - avg_active) / total_comparators) * 100
    
    return redundancy


def calculate_efficiency(n: int, comparator_count: int) -> float:
    """
    Calculate the efficiency of the network compared to theoretical lower bounds.
    
    Args:
        n: Number of inputs
        comparator_count: Number of comparators in the network
        
    Returns:
        Efficiency percentage (0-100)
    """
    # Handle edge cases
    if comparator_count == 0:
        return 100.0 if n <= 1 else 0.0
    
    # Theoretical lower bound is approximately n log n / 2
    # For small n, we use known optimal values
    optimal_sizes = {
        1: 0, 2: 1, 3: 3, 4: 5, 5: 9, 6: 12, 7: 16, 8: 19,
        9: 25, 10: 29, 11: 35, 12: 39, 13: 45, 14: 51, 15: 56, 16: 60
    }
    
    if n in optimal_sizes:
        theoretical_min = optimal_sizes[n]
    else:
        # Use approximation for larger n
        theoretical_min = max(1, int(0.5 * n * np.log2(n))) if n > 1 else 0
    
    # Calculate efficiency
    efficiency = (theoretical_min / comparator_count) * 100
    
    return efficiency


def find_layer_structure(comparators: List[Tuple[int, int]], n_wires: int) -> List[List[Tuple[int, int]]]:
    """
    Find the layer structure of the sorting network.
    This is an alias for find_parallel_layers to maintain interface consistency.
    
    Args:
        comparators: List of (i,j) comparator pairs
        n_wires: Number of wires
        
    Returns:
        List of lists containing comparators that can be executed in parallel
    """
    return find_parallel_layers(comparators, n_wires)


def get_network_properties_summary(n_wires: int) -> Dict:
    """
    Get a comprehensive summary of network properties.
    
    Args:
        n_wires: Number of wires to analyze
        
    Returns:
        Dictionary with all network properties
    """
    comparators = generate_sorting_network(n_wires)
    
    # Verify zero-one principle (only for small n)
    is_valid = None
    if n_wires <= 6:  # Limit to feasible computation
        is_valid = verify_zero_one_principle(n_wires, comparators)
    
    # Get layer properties
    layer_data = analyze_layer_properties(comparators, n_wires)
    
    # Get wire usage
    wire_data = analyze_wire_usage(comparators, n_wires)
    
    # Get redundancy
    redundancy = calculate_redundancy(comparators, n_wires)
    
    # Get efficiency
    efficiency = calculate_efficiency(n_wires, len(comparators))
    
    # Comparator distribution
    comp_dist = analyze_comparator_distribution(comparators, n_wires)
    
    return {
        "num_inputs": n_wires,
        "num_comparators": len(comparators),
        "depth": layer_data["total_layers"],
        "zero_one_verified": is_valid,
        "redundancy": redundancy,
        "efficiency": efficiency,
        "layer_properties": layer_data,
        "wire_usage": wire_data,
        "comparator_distribution": comp_dist
    } 