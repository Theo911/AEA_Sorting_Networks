"""
Network Properties Analysis for Batcher's Odd-Even Mergesort.

This module analyzes the mathematical properties of sorting networks
generated by Batcher's Odd-Even Mergesort algorithm, including:
- Zero-one principle verification
- Parallel execution layers analysis
- Network structure properties
"""

import itertools
import numpy as np
from typing import List, Tuple, Dict
import matplotlib.pyplot as plt
import os

from batcher_odd_even_mergesort import generate_sorting_network, apply_comparators

# Create results directory if it doesn't exist
RESULTS_DIR = "results"
os.makedirs(RESULTS_DIR, exist_ok=True)


def verify_zero_one_principle(n: int, comparators: List[Tuple[int, int]]) -> bool:
    """
    Verify that the network sorts all 2^n binary inputs correctly.
    
    Args:
        n: Number of inputs
        comparators: List of (i,j) comparator pairs
        
    Returns:
        True if the network sorts all binary inputs correctly
    """
    # Generate all 2^n binary inputs
    for input_bits in itertools.product([0, 1], repeat=n):
        output = apply_comparators(list(input_bits), comparators)
        
        # Check if sorted
        if not all(output[i] <= output[i+1] for i in range(len(output)-1)):
            return False
    
    return True


def find_parallel_layers(comparators: List[Tuple[int, int]], n_wires: int) -> List[List[Tuple[int, int]]]:
    """
    Identify comparators that can be executed in parallel.
    
    Args:
        comparators: List of (i,j) comparator pairs
        n_wires: Number of wires
        
    Returns:
        List of lists containing comparators that can be executed in parallel
    """
    layers = []
    wire_usage = [-1] * n_wires  # Last layer where each wire was used
    
    for i, j in comparators:
        # Find the earliest layer where this comparator can be placed
        earliest_layer = max(wire_usage[i], wire_usage[j]) + 1
        
        # Add layers if needed
        while len(layers) <= earliest_layer:
            layers.append([])
        
        # Add comparator to layer
        layers[earliest_layer].append((i, j))
        wire_usage[i] = earliest_layer
        wire_usage[j] = earliest_layer
    
    return layers


def analyze_layer_properties(comparators: List[Tuple[int, int]], n_wires: int) -> Dict:
    """
    Analyze properties of parallel execution layers.
    
    Args:
        comparators: List of (i,j) comparator pairs
        n_wires: Number of wires
        
    Returns:
        Dictionary with layer properties
    """
    layers = find_parallel_layers(comparators, n_wires)
    
    # Analyze each layer
    layer_sizes = [len(layer) for layer in layers]
    
    return {
        "total_layers": len(layers),
        "layers": layers,
        "layer_sizes": layer_sizes,
        "max_comparators_per_layer": max(layer_sizes) if layer_sizes else 0,
        "min_comparators_per_layer": min(layer_sizes) if layer_sizes else 0,
        "avg_comparators_per_layer": sum(layer_sizes) / len(layers) if layers else 0
    }


def analyze_wire_usage(comparators: List[Tuple[int, int]], n_wires: int) -> Dict:
    """
    Analyze how many times each wire is used in comparators.
    
    Args:
        comparators: List of (i,j) comparator pairs
        n_wires: Number of wires
        
    Returns:
        Dictionary with wire usage statistics
    """
    wire_usage = [0] * n_wires
    
    for i, j in comparators:
        wire_usage[i] += 1
        wire_usage[j] += 1
    
    return {
        "wire_usage": wire_usage,
        "max_usage": max(wire_usage),
        "min_usage": min(wire_usage),
        "avg_usage": sum(wire_usage) / n_wires
    }


def analyze_comparator_distribution(comparators: List[Tuple[int, int]], n_wires: int) -> Dict:
    """
    Analyze the distribution of comparators across wire pairs.
    
    Args:
        comparators: List of (i,j) comparator pairs
        n_wires: Number of wires
        
    Returns:
        Dictionary with comparator distribution information
    """
    # Count occurrences of each wire pair
    pair_counts = {}
    for i, j in comparators:
        if (i, j) in pair_counts:
            pair_counts[(i, j)] += 1
        else:
            pair_counts[(i, j)] = 1
    
    # Analyze distribution
    counts = list(pair_counts.values())
    
    return {
        "pair_counts": pair_counts,
        "unique_pairs": len(pair_counts),
        "max_count": max(counts) if counts else 0,
        "min_count": min(counts) if counts else 0,
        "avg_count": sum(counts) / len(counts) if counts else 0
    }


def compute_comparisons_per_input(comparators: List[Tuple[int, int]], n_wires: int, trials: int = 100) -> Dict:
    """
    Compute the average number of comparisons actually performed for random inputs.
    
    Args:
        comparators: List of (i,j) comparator pairs
        n_wires: Number of wires
        trials: Number of random trials
        
    Returns:
        Dictionary with comparison statistics
    """
    comparison_counts = []
    
    for _ in range(trials):
        # Generate random input
        input_values = np.random.randint(0, 100, n_wires).tolist()
        
        # Track comparisons
        count = 0
        current = input_values.copy()
        
        for i, j in comparators:
            # If comparison leads to swap, count it as active
            if current[i] > current[j]:
                current[i], current[j] = current[j], current[i]
                count += 1
        
        comparison_counts.append(count)
    
    return {
        "active_comparisons": comparison_counts,
        "max_comparisons": max(comparison_counts),
        "min_comparisons": min(comparison_counts),
        "avg_comparisons": sum(comparison_counts) / len(comparison_counts)
    }


def plot_wire_usage(n_wires: int) -> None:
    """
    Plot the usage of each wire in the network.
    
    Args:
        n_wires: Number of wires to analyze
    """
    comparators = generate_sorting_network(n_wires)
    usage_data = analyze_wire_usage(comparators, n_wires)
    
    plt.figure(figsize=(10, 6))
    plt.bar(range(n_wires), usage_data["wire_usage"])
    plt.xlabel('Wire Index')
    plt.ylabel('Number of Uses in Comparators')
    plt.title(f"Wire Usage in Batcher's Network (n={n_wires})")
    plt.grid(True, axis='y')
    plt.xticks(range(n_wires))
    plt.savefig(os.path.join(RESULTS_DIR, f'wire_usage_n{n_wires}.png'))


def plot_layer_sizes(n_wires: int) -> None:
    """
    Plot the number of comparators in each parallel layer.
    
    Args:
        n_wires: Number of wires to analyze
    """
    comparators = generate_sorting_network(n_wires)
    layer_data = analyze_layer_properties(comparators, n_wires)
    
    plt.figure(figsize=(10, 6))
    plt.bar(range(layer_data["total_layers"]), layer_data["layer_sizes"])
    plt.xlabel('Layer Index')
    plt.ylabel('Number of Comparators')
    plt.title(f"Comparators per Layer in Batcher's Network (n={n_wires})")
    plt.grid(True, axis='y')
    plt.xticks(range(layer_data["total_layers"]))
    plt.savefig(os.path.join(RESULTS_DIR, f'layer_sizes_n{n_wires}.png'))


def print_network_analysis(n_wires: int) -> None:
    """
    Print a comprehensive analysis of the network properties.
    
    Args:
        n_wires: Number of wires to analyze
    """
    comparators = generate_sorting_network(n_wires)
    
    # Only verify zero-one principle for small n
    is_valid = "Too large to verify" if n_wires > 8 else verify_zero_one_principle(n_wires, comparators)
    
    # Get layer properties
    layer_data = analyze_layer_properties(comparators, n_wires)
    
    # Get wire usage
    usage_data = analyze_wire_usage(comparators, n_wires)
    
    # Get comparison stats
    comparison_data = compute_comparisons_per_input(comparators, n_wires)
    
    # Print results
    print(f"\nNetwork Analysis for Batcher's Odd-Even Mergesort (n={n_wires}):")
    print("-" * 60)
    print(f"Total comparators: {len(comparators)}")
    print(f"Network depth (parallel steps): {layer_data['total_layers']}")
    print(f"Zero-one principle verified: {is_valid}")
    print(f"Average comparators per layer: {layer_data['avg_comparators_per_layer']:.2f}")
    print(f"Maximum comparators in a layer: {layer_data['max_comparators_per_layer']}")
    print(f"Minimum comparators in a layer: {layer_data['min_comparators_per_layer']}")
    print(f"Average wire usage: {usage_data['avg_usage']:.2f}")
    print(f"Maximum wire usage: {usage_data['max_usage']}")
    print(f"Minimum wire usage: {usage_data['min_usage']}")
    print(f"Average active comparisons: {comparison_data['avg_comparisons']:.2f} out of {len(comparators)} ({comparison_data['avg_comparisons']/len(comparators)*100:.1f}%)")
    
    # Save to file
    with open(os.path.join(RESULTS_DIR, f'network_analysis_n{n_wires}.md'), 'w') as f:
        f.write(f"# Network Analysis for Batcher's Odd-Even Mergesort (n={n_wires})\n\n")
        f.write(f"- **Total comparators:** {len(comparators)}\n")
        f.write(f"- **Network depth (parallel steps):** {layer_data['total_layers']}\n")
        f.write(f"- **Zero-one principle verified:** {is_valid}\n")
        f.write(f"- **Average comparators per layer:** {layer_data['avg_comparators_per_layer']:.2f}\n")
        f.write(f"- **Maximum comparators in a layer:** {layer_data['max_comparators_per_layer']}\n")
        f.write(f"- **Minimum comparators in a layer:** {layer_data['min_comparators_per_layer']}\n")
        f.write(f"- **Average wire usage:** {usage_data['avg_usage']:.2f}\n")
        f.write(f"- **Maximum wire usage:** {usage_data['max_usage']}\n")
        f.write(f"- **Minimum wire usage:** {usage_data['min_usage']}\n")
        f.write(f"- **Average active comparisons:** {comparison_data['avg_comparisons']:.2f} out of {len(comparators)} ({comparison_data['avg_comparisons']/len(comparators)*100:.1f}%)\n\n")
        
        # Write layer data
        f.write("## Parallel Execution Layers\n\n")
        f.write("| Layer | Comparators |\n")
        f.write("|-------|-------------|\n")
        
        for i, layer in enumerate(layer_data["layers"]):
            f.write(f"| {i} | {layer} |\n")


if __name__ == "__main__":
    print("Analyzing network properties for Batcher's Odd-Even Mergesort...")
    
    # Analyze networks for different sizes
    for n in [4, 8, 16]:
        print(f"\nAnalyzing n={n}...")
        comparators = generate_sorting_network(n)
        
        # Verify zero-one principle for small n
        if n <= 8:
            is_valid = verify_zero_one_principle(n, comparators)
            print(f"Zero-one principle verified: {is_valid}")
        
        # Analyze and print properties
        print_network_analysis(n)
        
        # Plot wire usage
        plot_wire_usage(n)
        
        # Plot layer sizes
        plot_layer_sizes(n)
    
    print("\nAnalysis complete. Results saved to output files.")
    
    plt.show() 